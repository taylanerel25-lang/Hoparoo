<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <title>Hoparoo</title>
  <style>
    :root{--accent:#22c55e;--panel:rgba(255,255,255,.92);--ink:#0b0d10}
    html, body { height: 100%; margin: 0; background:#0b0d10; color:#fff; overflow:hidden; font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans"; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    /* HUD / Splash inspired by Flipper Fish (no leaderboard, no store) */
    .hud { position:fixed; inset:0; pointer-events:none; }
    .score { position:fixed; top: calc(env(safe-area-inset-top) + 18px); right: 14px; font-size: 56px; color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); z-index:3; user-select:none; }
    .best { position:fixed; top: calc(env(safe-area-inset-top) + 28px); left:14px; font-size:16px; color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); z-index:3; user-select:none; }
    .splash { position:fixed; inset:0; z-index:2; display:block; }
    .splash-inner { position:absolute; left:50%; transform:translateX(-50%); top:10%; width:min(92%,360px); text-align:center; }
    .title { font-size: 40px; font-weight: 1000; color:#fff; text-shadow:0 8px 24px rgba(0,0,0,.45); margin:0 0 6px; }
    .subtitle { font-size:16px; opacity:.95 }
    .panel { min-width:280px; max-width:90vw; background:var(--panel); color:#111; border-radius:18px; padding:16px; box-shadow:0 10px 40px rgba(0,0,0,.35); pointer-events:auto; }
    .btn { appearance:none; border:0; background:#fff; color:#111; padding:10px 14px; border-radius:999px; font-weight:800; box-shadow:0 2px 8px rgba(0,0,0,.15); cursor:pointer; line-height:1; }
    .btn:focus{ outline:3px solid #000; outline-offset:2px; }
    .actions { display:grid; gap:10px; margin-top:12px; justify-items:center; }
    .toast { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.85); color: #fff; padding: 8px 12px; border-radius: 10px; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity .25s ease, transform .25s ease; }
    .toast.show { opacity: 1; transform: translate(-50%, -6px); }
    .modal { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.35); z-index:9999; }
    .sr-only { position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    /* Light mode support */
    @media (prefers-color-scheme: light) {
      html,body{ background:#f3f5f7; color:#111; }
      .title{color:#111; text-shadow:none;}
    }
  </style>
</head>
<body>
  <canvas id="game" aria-label="Hoparoo"></canvas>

  <!-- HUD / Splash UI (DOM overlay) -->
  <div class="hud" aria-hidden="true">
    <div class="score"><span id="scoreHud">0</span></div>
    <div id="bestHud" class="best">Best: 0</div>
    <div id="splash" class="splash">
      <div class="splash-inner">
        <div class="title">Hoparoo</div>
        <div class="subtitle">Tap to jump • Dodge the outback</div>
        <div style="margin-top:12px; display:grid; gap:10px; justify-items:center; pointer-events:auto;">
          <button id="startBtn" class="btn" style="background:var(--accent); color:#04130a;">Play</button>
          <button id="howToBtn" class="btn">How to Play</button>
        </div>
      </div>
    </div>
  </div>

  <div id="gameOver" class="hud" style="display:none;">
    <div class="panel" role="dialog" aria-modal="true" aria-labelledby="overTitle" style="position:absolute; left:50%; top:45%; transform:translate(-50%,-50%);">
      <h2 id="overTitle" style="margin:0 0 8px; text-align:center;">Game Over</h2>
      <div style="display:flex; justify-content:space-between; font-size:18px; padding:6px 0;"><span>Your Score</span><strong id="scoreNow">0</strong></div>
      <div style="display:flex; justify-content:space-between; font-size:18px; padding:6px 0;"><span>Best</span><strong id="bestNow">0</strong></div>
      <div class="actions">
        <button id="againBtn" class="btn">Play Again</button>
        <button id="shareBtn" class="btn">Share</button>
      </div>
    </div>
  </div>

  <div id="howToModal" class="modal" role="dialog" aria-modal="true">
    <div class="panel" style="text-align:left;">
      <h3 style="margin:0 0 8px; text-align:center;">How to Play</h3>
      <p style="margin:0; line-height:1.45; font-size:15px;">
        • Roo runs automatically to the right<br>
        • Tap anywhere to jump<br>
        • Jump over obstacles on the ground<br>
        • Hitting anything ends the run — quick restart, go again
      </p>
      <div class="actions"><button id="closeHowToBtn" class="btn">Close</button></div>
    </div>
  </div>

  <div id="aria" class="sr-only" aria-live="polite"></div>
  <div id="toast" class="toast" role="status"></div>

<script>
(() => {
  'use strict';

  // ======= TWEAK ZONE =======
  const RUN_SPEED = 300;                // world scroll speed (px/s)
  const GRAVITY = 2200;                 // px/s^2
  const JUMP_VELOCITY = -900;           // px/s (negative = up)
  const GROUND_RATIO = 0.78;            // ground baseline (fraction of screen height)
  const ROO = { w: 64, h: 46 };         // kangaroo hitbox
  const BOB = { amp: 6, freq: 6.5 };    // tiny hop/bob when grounded (visual only)
  const SPAWN_GAP = { min: 380, max: 720 }; // distance between obstacles (px)
  const SAFE_START_MS = 1200;           // no obstacles at the very start

  // Blue sky gradient
  const SKY = ['#78c6ff', '#d9f0ff'];

  // Ground / colors
  const GROUND_COLOR = '#2e3a45';
  const KANGAROO_COLOR = '#22c55e';
  const OBSTACLE_COLORS = ['#f59e0b', '#ef4444', '#60a5fa'];
  const OBSTACLE_TYPES = [
    { name: 'rock',   w: 38, h: 34 },
    { name: 'emu',    w: 28, h: 62 },
    { name: 'roo',    w: 52, h: 42 },
  ];

  // Background assets (paste your GitHub RAW links here)
  const BG_BACK_URL  = ''; // e.g. 'https://raw.githubusercontent.com/USER/REPO/branch/assets/trees_back.png?v=1'
  const BG_FRONT_URL = ''; // e.g. 'https://raw.githubusercontent.com/USER/REPO/branch/assets/trees_front.png?v=1'
  const BG_SCROLL = { back: 0.25, front: 0.55 }; // parallax speed fractions
  // ======= /TWEAK ZONE =======

  // DOM refs (Flipper-style overlays)
  const splashEl = document.getElementById('splash');
  const startBtn = document.getElementById('startBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const gameOverEl = document.getElementById('gameOver');
  const scoreNow = document.getElementById('scoreNow');
  const bestNow = document.getElementById('bestNow');
  const againBtn = document.getElementById('againBtn');
  const shareBtn = document.getElementById('shareBtn');
  const hudScore = document.getElementById('scoreHud');
  const bestHud = document.getElementById('bestHud');
  const toast = document.getElementById('toast');

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // Canvas / layout
  let W = 0, H = 0, GROUND_Y = 0;

  // Parallax state
  let bgBackImg = null, bgFrontImg = null, bgBackLoaded = false, bgFrontLoaded = false;
  let bgBackX = 0, bgFrontX = 0;
  let BACK_H = 0, FRONT_H = 0, backY = 0, frontY = 0;

  function loadBG() {
    if (BG_BACK_URL) {
      bgBackImg = new Image();
      bgBackImg.crossOrigin = 'anonymous';
      bgBackImg.src = BG_BACK_URL;
      bgBackImg.onload = () => (bgBackLoaded = true);
    }
    if (BG_FRONT_URL) {
      bgFrontImg = new Image();
      bgFrontImg.crossOrigin = 'anonymous';
      bgFrontImg.src = BG_FRONT_URL;
      bgFrontImg.onload = () => (bgFrontLoaded = true);
    }
  }
  loadBG();

  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    GROUND_Y = Math.floor(H * GROUND_RATIO);

    // background layer sizing anchored to ground
    BACK_H  = Math.floor(H * 0.42);
    FRONT_H = Math.floor(H * 0.56);
    backY   = GROUND_Y - BACK_H;
    frontY  = GROUND_Y - FRONT_H;
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // Game state
  const state = {
    playing: false,
    dead: false,
    time: 0,
    score: 0,
    best: Number(localStorage.getItem('hoparoo_best')||0),
    distSinceSpawn: 0,
    nextGap: rand(SPAWN_GAP.min, SPAWN_GAP.max),
    startedAt: 0,
  };
  bestHud.textContent = `Best: ${state.best}`;

  // Roo (player)
  const roo = { x: Math.max(80, W * 0.18), y: 0, vy: 0, grounded: true, bobT: 0 };
  function placeRooOnGround() { roo.y = GROUND_Y - ROO.h; roo.vy = 0; roo.grounded = true; }
  placeRooOnGround();

  // Obstacles
  const obstacles = [];
  function spawnObstacle() {
    const t = OBSTACLE_TYPES[(Math.random() * OBSTACLE_TYPES.length) | 0];
    const color = OBSTACLE_COLORS[(Math.random() * OBSTACLE_COLORS.length) | 0];
    const h = t.h; const w = t.w; const y = GROUND_Y - h; const x = W + rand(12, 48);
    obstacles.push({ x, y, w, h, type: t.name, color });
  }

  // Input
  function jump() {
    if (state.dead) return;
    if (!state.playing) { startGame(); return; }
    if (roo.grounded) { roo.vy = JUMP_VELOCITY; roo.grounded = false; }
  }
  window.addEventListener('pointerdown', jump);
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { e.preventDefault(); jump(); }
    if (state.dead && (e.code === 'Space' || e.code === 'Enter')) doPlayAgain();
  });

  document.addEventListener('visibilitychange', () => { lastTime = performance.now(); });

  function startGame() {
    state.playing = true; state.dead = false; state.time = 0; state.score = 0;
    state.distSinceSpawn = 0; state.nextGap = rand(SPAWN_GAP.min, SPAWN_GAP.max); state.startedAt = performance.now();
    obstacles.length = 0; placeRooOnGround();
    hudScore.textContent = '0';
    splashEl.style.display = 'none';
    gameOverEl.style.display = 'none';
  }

  function gameOver() {
    state.dead = true; state.playing = false;
    state.best = Math.max(state.best, Math.floor(state.score));
    localStorage.setItem('hoparoo_best', String(state.best));
    bestHud.textContent = `Best: ${state.best}`;
    scoreNow.textContent = `${Math.floor(state.score)}`;
    bestNow.textContent = `${state.best}`;
    setTimeout(() => { gameOverEl.style.display = ''; }, 150);
  }

  function doPlayAgain(){
    gameOverEl.style.display = 'none';
    // Return to splash so user taps to start
    splashEl.style.display = '';
    state.dead = false; state.playing = false; state.score = 0;
    obstacles.length = 0; placeRooOnGround(); hudScore.textContent = '0';
  }

  startBtn.addEventListener('click', startGame);
  howToBtn.addEventListener('click', () => { howToModal.style.display = 'grid'; });
  closeHowToBtn.addEventListener('click', () => { howToModal.style.display = 'none'; });
  howToModal.addEventListener('click', (e) => { if (e.target === howToModal) howToModal.style.display = 'none'; });
  againBtn.addEventListener('click', doPlayAgain);
  shareBtn.addEventListener('click', async () => {
    const text = `I scored ${Math.floor(state.score)} in Hoparoo!`;
    try {
      if (navigator.share) await navigator.share({ text, title: 'Hoparoo' });
      else { await navigator.clipboard.writeText(text); showToast('Copied to clipboard'); }
    } catch {}
  });

  function showToast(msg){ toast.textContent = msg; toast.classList.add('show'); clearTimeout(showToast._t); showToast._t = setTimeout(()=> toast.classList.remove('show'), 1200); }

  // Main loop
  let lastTime = performance.now();
  function loop(now) {
    const rawDt = (now - lastTime) / 1000; lastTime = now; const dt = Math.min(0.033, Math.max(0.001, rawDt));
    update(dt); draw(); requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt) {
    // Parallax scroll (subtle motion even on splash)
    bgBackX  += RUN_SPEED * BG_SCROLL.back  * dt;
    bgFrontX += RUN_SPEED * BG_SCROLL.front * dt;

    if (state.playing) state.score += (RUN_SPEED * dt) * 0.1;
    hudScore.textContent = `${Math.floor(state.score)}`;

    if (state.playing && (performance.now() - state.startedAt) > SAFE_START_MS) {
      state.distSinceSpawn += RUN_SPEED * dt;
      if (state.distSinceSpawn >= state.nextGap) {
        spawnObstacle(); state.distSinceSpawn = 0;
        const ramp = Math.max(0.6, 1 - state.score / 2000);
        state.nextGap = rand(SPAWN_GAP.min * ramp, SPAWN_GAP.max * ramp);
      }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      if (state.playing) o.x -= RUN_SPEED * dt;
      if (o.x + o.w < -20) obstacles.splice(i, 1);
    }

    if (state.playing) {
      if (!roo.grounded) {
        roo.vy += GRAVITY * dt; roo.y += roo.vy * dt;
        if (roo.y >= GROUND_Y - ROO.h) { placeRooOnGround(); }
      } else {
        roo.bobT += dt * BOB.freq;
      }
      const rb = { x: roo.x, y: roo.y, w: ROO.w, h: ROO.h };
      for (const o of obstacles) { if (rectsOverlap(rb, o)) { gameOver(); break; } }
    }
  }

  function draw() {
    drawSky(); drawGround();
    for (const o of obstacles) drawObstacle(o);
    drawRoo();
  }

  function drawSky() {
    // Sky gradient
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, SKY[0]); g.addColorStop(1, SKY[1]);
    ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

    // Lightweight clouds
    const t = performance.now() * 0.00006;
    ctx.globalAlpha = 0.14;
    for (let i = 0; i < 10; i++) {
      const cx = ((i * 311) - (t * 900)) % (W + 220) - 110;
      const cy = 40 + (i * 53) % (GROUND_Y * 0.6);
      const rw = 160 + (i % 3) * 60, rh = 40 + (i % 2) * 12;
      roundedRect(cx, cy, rw, rh, 20); ctx.fillStyle = '#ffffff'; ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Parallax bands
    drawParallaxBand({
      img: bgBackImg, loaded: bgBackLoaded,
      xOffset: bgBackX, y: backY, h: BACK_H, speedFrac: BG_SCROLL.back,
      fallbackColor: '#4b6b4b', detailColor: '#2f4a2f', density: 0.6
    });

    drawParallaxBand({
      img: bgFrontImg, loaded: bgFrontLoaded,
      xOffset: bgFrontX, y: frontY, h: FRONT_H, speedFrac: BG_SCROLL.front,
      fallbackColor: '#2f4a2f', detailColor: '#1e331e', density: 0.9
    });
  }

  function drawGround() {
    ctx.fillStyle = GROUND_COLOR; ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
    const dashW = 32, dashH = 3, gap = 20;
    const offset = -((performance.now() * RUN_SPEED * 0.002) % (dashW + gap));
    ctx.globalAlpha = 0.35; ctx.fillStyle = '#9ca3af';
    for (let x = offset; x < W + dashW; x += dashW + gap) ctx.fillRect(x, GROUND_Y + 18, dashW, dashH);
    ctx.globalAlpha = 1;
  }

  function drawObstacle(o) {
    ctx.fillStyle = o.color;
    if (o.type === 'emu') {
      ctx.fillRect(o.x, o.y, o.w, o.h - 12);
      ctx.fillRect(o.x + o.w - 12, o.y - 8, 12, 12);
    } else if (o.type === 'roo') {
      roundedRect(o.x, o.y + 6, o.w, o.h - 6, 8); ctx.fill();
      ctx.fillRect(o.x + o.w - 10, o.y - 6, 10, 12);
    } else {
      roundedRect(o.x, o.y + 8, o.w, o.h - 8, 6); ctx.fill();
    }
  }

  function drawRoo() {
    const bobOffset = (roo.grounded ? Math.sin(roo.bobT) * BOB.amp : 0);
    const x = roo.x, y = roo.y + bobOffset;
    ctx.fillStyle = KANGAROO_COLOR; roundedRect(x, y + 6, ROO.w, ROO.h - 6, 10); ctx.fill();
    ctx.fillRect(x + ROO.w - 18, y - 10, 18, 18); // head
    ctx.fillRect(x + ROO.w - 10, y - 20, 8, 12);  // ear
    ctx.fillRect(x - 14, y + 12, 14, 6);          // tail
    if (roo.grounded) {
      ctx.globalAlpha = 0.4;
      ctx.fillRect(x + 6, GROUND_Y - 2, 22, 2);
      ctx.fillRect(x + ROO.w - 28, GROUND_Y - 2, 22, 2);
      ctx.globalAlpha = 1;
    }
  }

  // ===== Utils =====
  function rand(min, max) { return min + Math.random() * (max - min); }
  function rectsOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  function roundedRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2); ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y); ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr); ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
    ctx.lineTo(x, y + rr); ctx.quadraticCurveTo(x, y, x + rr, y);
  }

  // Draw and tile an image parallax band; fallback to tree silhouettes
  function drawParallaxBand({ img, loaded, xOffset, y, h, fallbackColor, detailColor, density }) {
    if (loaded && img && img.width && img.height) {
      const scale = h / img.height;
      const tileW = img.width * scale;
      let x = -((xOffset % tileW) + tileW);
      for (; x < W + tileW; x += tileW) {
        ctx.drawImage(img, x, y, tileW, h);
      }
    } else {
      // Fallback: simple repeating tree silhouettes
      ctx.fillStyle = fallbackColor;
      ctx.fillRect(0, y + h - 12, W, 12); // small ridge
      const base = Math.max(48, h * 0.25);
      let rng = (n) => { n ^= n << 13; n ^= n >>> 17; n ^= n << 5; return (n >>> 0) / 4294967296; };
      const seed = (Math.floor(performance.now() * 0.05) | 0);
      const step = 36;
      for (let i = -40; i < Math.ceil(W / step) + 40; i++) {
        const r = rng(i * 73856093 ^ seed);
        const w = 14 + (r * 22);
        const hh = base + r * (h * 0.55);
        const xx = (i * step) - ((xOffset * 0.3) % step);
        // trunk
        ctx.fillStyle = detailColor;
        ctx.fillRect(xx + w * 0.45, y + h - hh, w * 0.1, hh);
        // canopy (three stacked blobs)
        ctx.fillStyle = fallbackColor;
        roundedRect(xx, y + h - hh - 10, w, hh * 0.55, 6); ctx.fill();
        roundedRect(xx - 6, y + h - hh * 0.7, w + 12, hh * 0.45, 8); ctx.fill();
        roundedRect(xx - 12, y + h - hh * 0.5, w + 24, hh * 0.35, 10); ctx.fill();
      }
    }
  }
})();
</script>
</body>
</html>
