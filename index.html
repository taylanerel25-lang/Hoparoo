<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <title>Hoparoo</title>
  <style>
    :root{--accent:#22c55e;--panel:rgba(255,255,255,.92);--ink:#0b0d10}
    html, body { height: 100%; margin: 0; background:#0b0d10; color:#fff; overflow:hidden; font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans"; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    .hud { position:fixed; inset:0; pointer-events:none; }
    .score { position:fixed; top: calc(env(safe-area-inset-top) + 18px); right: 14px; font-size: 56px; color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); z-index:3; user-select:none; }
    .best { position:fixed; top: calc(env(safe-area-inset-top) + 28px); left:14px; font-size:16px; color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); z-index:3; user-select:none; }
    .splash { position:fixed; inset:0; z-index:2; display:block; }
    .splash-inner { position:absolute; left:50%; transform:translateX(-50%); top:10%; width:min(92%,360px); text-align:center; }
    .title { font-size: 40px; font-weight: 1000; color:#fff; text-shadow:0 8px 24px rgba(0,0,0,.45); margin:0 0 6px; }
    .subtitle { font-size:16px; opacity:.95 }
    .panel { min-width:280px; max-width:90vw; background:var(--panel); color:#111; border-radius:18px; padding:16px; box-shadow:0 10px 40px rgba(0,0,0,.35); pointer-events:auto; }
    .btn { appearance:none; border:0; background:#fff; color:#111; padding:10px 14px; border-radius:999px; font-weight:800; box-shadow:0 2px 8px rgba(0,0,0,.15); cursor:pointer; line-height:1; }
    .btn:focus{ outline:3px solid #000; outline-offset:2px; }
    .actions { display:grid; gap:10px; margin-top:12px; justify-items:center; }
    .toast { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.85); color: #fff; padding: 8px 12px; border-radius: 10px; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity .25s ease, transform .25s ease; }
    .toast.show { opacity: 1; transform: translate(-50%, -6px); }
    .modal { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.35); z-index:9999; }
    .sr-only { position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    @media (prefers-color-scheme: light) {
      html,body{ background:#f3f5f7; color:#111; }
      .title{color:#111; text-shadow:none;}
    }
  </style>
</head>
<body>
  <canvas id="game" aria-label="Hoparoo"></canvas>

  <div class="hud" aria-hidden="true">
    <div class="score"><span id="scoreHud">0</span></div>
    <div id="bestHud" class="best">Best: 0</div>
    <div id="splash" class="splash">
      <div class="splash-inner">
        <div class="title">Hoparoo</div>
        <div class="subtitle">Tap to jump • Dodge the outback</div>
        <div style="margin-top:12px; display:grid; gap:10px; justify-items:center; pointer-events:auto;">
          <button id="startBtn" class="btn" style="background:var(--accent); color:#04130a;">Play</button>
          <button id="howToBtn" class="btn">How to Play</button>
        </div>
      </div>
    </div>
  </div>

  <div id="gameOver" class="hud" style="display:none;">
    <div class="panel" role="dialog" aria-modal="true" aria-labelledby="overTitle" style="position:absolute; left:50%; top:45%; transform:translate(-50%,-50%);">
      <h2 id="overTitle" style="margin:0 0 8px; text-align:center;">Game Over</h2>
      <div style="display:flex; justify-content:space-between; font-size:18px; padding:6px 0;"><span>Your Score</span><strong id="scoreNow">0</strong></div>
      <div style="display:flex; justify-content:space-between; font-size:18px; padding:6px 0;"><span>Best</span><strong id="bestNow">0</strong></div>
      <div class="actions">
        <button id="againBtn" class="btn">Play Again</button>
        <button id="shareBtn" class="btn">Share</button>
      </div>
    </div>
 </div>

  <div id="howToModal" class="modal" role="dialog" aria-modal="true">
    <div class="panel" style="text-align:left;">
      <h3 style="margin:0 0 8px; text-align:center;">How to Play</h3>
      <p style="margin:0; line-height:1.45; font-size:15px;">
        • Roo runs automatically to the right<br>
        • Tap anywhere to jump<br>
        • Jump over obstacles on the ground<br>
        • Hitting anything ends the run — quick restart, go again
      </p>
      <div class="actions"><button id="closeHowToBtn" class="btn">Close</button></div>
    </div>
  </div>

  <div id="aria" class="sr-only" aria-live="polite"></div>
  <div id="toast" class="toast" role="status"></div>

<script>
(() => {
  'use strict';

  // ======= TWEAK ZONE =======
  const RUN_SPEED = 300;
  const GRAVITY = 2000;
  const JUMP_VELOCITY = -720;
  const GROUND_RATIO = 0.78;
  const FADE_W = 128;

  const ROO = { w: 130, h: 94 };
  const ROO_TILT = { up: -0.18, down: 0.22, max: 0.28 };
  const ROO_COLORS = {
    base: '#22c55e',
    mid: '#16a34a',
    dark: '#15803d',
    belly: '#bbf7d0',
    accent: '#0f172a'
  };

  // === TREES / PARALLAX ===
  const BG_FRONT_URL = 'https://raw.githubusercontent.com/taylanerel25-lang/Hoparoo/main/trees.png'; // lowercase!
  const BG_BACK_URL = '';
  const BG_SCROLL = { back: 0.22, front: 0.55 };
  const BG_CHROMA = [0,0,0];
  const BG_CHROMA_TOL = 34;
  const BG_MIRROR_TILING = true;

  const BOB = { amp: 28, freq: 6.8 };
  const SPAWN_GAP = { min: 380, max: 720 };
  const SAFE_START_MS = 1200;

  const SKY = ['#78c6ff', '#d9f0ff'];
  const GROUND_COLOR = '#2e3a45';

  const OBSTACLE_COLORS = ['#f59e0b', '#ef4444', '#60a5fa'];
  const OBSTACLE_TYPES = [
    { name: 'rock',   w: 38, h: 34 },
    { name: 'emu',    w: 28, h: 62 },
    { name: 'roo',    w: 52, h: 42 },
  ];

  const BOUNCE_DAMPING = 0.7;
  // ======= /TWEAK ZONE =======

  // DOM refs
  const splashEl = document.getElementById('splash');
  const startBtn = document.getElementById('startBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const gameOverEl = document.getElementById('gameOver');
  const scoreNow = document.getElementById('scoreNow');
  const bestNow = document.getElementById('bestNow');
  const againBtn = document.getElementById('againBtn');
  const shareBtn = document.getElementById('shareBtn');
  const hudScore = document.getElementById('scoreHud');
  const bestHud = document.getElementById('bestHud');
  const toast = document.getElementById('toast');

  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  let W = 0, H = 0, GROUND_Y = 0;

  // Assets
  let bgBackImg = null, bgFrontImg = null, bgBackLoaded = false, bgFrontLoaded = false;

  // Parallax state
  let bgBackX = 0, bgFrontX = 0;
  let BACK_H = 0, FRONT_H = 0, backY = 0, frontY = 0;
  let bandBack = null, bandFront = null, bandBackW = 0, bandFrontW = 0;

  // Tree palettes
  const PALETTE_BACK = {
    leafLight: '#a8d5a8', leafMid: '#8ab88a', leafDark: '#6b9a6b',
    trunkLight: '#8c7a5e', trunkDark: '#5d4a36', shadow: 'rgba(0,0,0,0.12)'
  };
  const PALETTE_FRONT = {
    leafLight: '#4a9c5f', leafMid: '#3a7d4a', leafDark: '#2a5d38',
    trunkLight: '#7a6248', trunkDark: '#5a4530', shadow: 'rgba(0,0,0,0.18)'
  };

  // Load assets
  async function loadImages(){
    // Trees – keep chroma key
    if (BG_FRONT_URL) {
      try {
        bgFrontImg = await loadStripWithChroma(BG_FRONT_URL, BG_CHROMA, BG_CHROMA_TOL);
        addEdgeFades(bgFrontImg, FADE_W);
        bgFrontLoaded = true;
      } catch (e) {
        console.warn("Front trees failed to load.", e);
        bgFrontLoaded = false;
      }
    }

    if (!bgBackLoaded && bgFrontImg) {
      bgBackImg = makeVariant(bgFrontImg, 0.94, 0.86);
      addEdgeFades(bgBackImg, FADE_W);
      bgBackLoaded = true;
    }
  }
  loadImages();

  function addEdgeFades(c, fadeW) {
    if (c.width < fadeW * 2) return;
    const g = c.getContext('2d');
    g.globalCompositeOperation = 'destination-out';
    const leftGrad = g.createLinearGradient(0, 0, fadeW, 0);
@@ -307,52 +296,52 @@
    state.dead = false; state.playing = false; state.score = 0;
    obstacles.length = 0; placeRooOnGround(); hudScore.textContent = '0';
  }

  startBtn.addEventListener('click', startGame);
  howToBtn.addEventListener('click', () => { howToModal.style.display = 'grid'; });
  closeHowToBtn.addEventListener('click', () => { howToModal.style.display = 'none'; });
  howToModal.addEventListener('click', (e) => { if (e.target === howToModal) howToModal.style.display = 'none'; });
  againBtn.addEventListener('click', doPlayAgain);
  shareBtn.addEventListener('click', async () => {
    const text = `I scored ${state.score} in Hoparoo!`;
    try { if (navigator.share) await navigator.share({ text, title: 'Hoparoo' }); else { await navigator.clipboard.writeText(text); showToast('Copied to clipboard'); } } catch {}
  });

  function showToast(msg){ toast.textContent = msg; toast.classList.add('show'); clearTimeout(showToast._t); showToast._t = setTimeout(()=> toast.classList.remove('show'), 1200); }

  // Main loop
  let lastTime = performance.now();
  function loop(now) {
    const rawDt = (now - lastTime) / 1000; lastTime = now; const dt = Math.min(0.033, Math.max(0.001, rawDt));
    update(dt); draw(); requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt) {
    bgBackX  = (bgBackX + RUN_SPEED * BG_SCROLL.back  * dt) % 1000000;
    bgFrontX = (bgFrontX + RUN_SPEED * BG_SCROLL.front * dt) % 1000000;

    hudScore.textContent = `${state.score}`;

    if (state.playing && (performance.now() - state.startedAt) > SAFE_START_MS) {
      state.distSinceSpawn += RUN_SPEED * dt;
      if (state.distSinceSpawn >= state.nextGap) {
        spawnObstacle(); state.distSinceSpawn = 0;
        const ramp = Math.max(0.6, 1 - state.score / 2000);
        state.nextGap = rand(SPAWN_GAP.min * ramp, SPAWN_GAP.max * ramp);
      }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      if (state.playing) o.x -= RUN_SPEED * dt;
      if (o.x + o.w < -20) obstacles.splice(i, 1);
      if (state.playing && o.x + o.w < roo.x && !o.scored) {
        state.score += 1;
        o.scored = true;
      }
    }

    if (state.playing) {
      if (!roo.grounded) {
        roo.vy += GRAVITY * dt; roo.y += roo.vy * dt;
@@ -431,94 +420,211 @@

  function drawRoo(){
    const sinVal = Math.sin(roo.bobT);
    const bobOffset = (roo.grounded ? -Math.abs(sinVal) * BOB.amp : 0);
    const x = roo.x, y = roo.y + bobOffset;

    // Landing dust puff
    if (state.justLanded && roo.landT > 0) {
      ctx.save();
      ctx.globalAlpha = roo.landT * 2;
      ctx.filter = 'blur(2px)';
      ctx.fillStyle = '#d4a574';
      ctx.beginPath();
      ctx.ellipse(x + ROO.w * 0.5, GROUND_Y - 2, ROO.w * 0.6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      state.justLanded = false;
    }

    // Shadow
    ctx.save();
    ctx.globalAlpha = 0.3; ctx.filter='blur(2px)';
    ctx.beginPath(); ctx.ellipse(x + ROO.w*0.5, GROUND_Y - 2, ROO.w*0.45, 4, 0, 0, Math.PI*2);
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fill(); ctx.restore();

    drawStylizedRoo(x, y, sinVal, roo.vy, roo.grounded, roo.landT);
  }

  function drawStylizedRoo(x, y, strideSin, vy, grounded, landT) {
    const cx = x + ROO.w * 0.48;
    const cy = y + ROO.h * 0.54;
    const tilt = clamp(grounded ? -strideSin * 0.12 : (vy < 0 ? ROO_TILT.up : ROO_TILT.down), -ROO_TILT.max, ROO_TILT.max);
    const impact = landT > 0 ? clamp(landT * 5, 0, 1) : 0;
    const strideMag = Math.abs(strideSin);
    const crouch = grounded ? Math.min(1, strideMag * 0.6 + impact * 0.8) : 0;
    const airStretch = clamp(Math.abs(vy) / 900, 0, 0.45);
    let scaleX = 1;
    let scaleY = 1;

    if (grounded) {
      scaleX += crouch * 0.28;
      scaleY -= crouch * 0.32;
    } else if (vy < 0) {
      scaleX -= airStretch * 0.18;
      scaleY += airStretch * 0.35;
    } else {
      scaleX += airStretch * 0.2;
      scaleY -= airStretch * 0.28;
    }

    ctx.save();
    ctx.translate(cx, cy - crouch * 6);
    ctx.rotate(tilt);
    ctx.scale(scaleX, scaleY);

    const swing = clamp(strideSin * (grounded ? 1 : 0.4), -1, 1);

    const drawLeg = (offsetX, offsetY, angle, front) => {
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.rotate(angle);
      const len = ROO.h * 0.42;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(len * 0.14, len * 0.34, len * 0.22, len * 0.68);
      ctx.quadraticCurveTo(len * 0.32, len * 0.9, len * 0.02, len * 0.96);
      ctx.quadraticCurveTo(-len * 0.18, len * 0.78, -len * 0.08, len * 0.46);
      ctx.closePath();
      ctx.fillStyle = front ? ROO_COLORS.mid : ROO_COLORS.dark;
      ctx.fill();
      ctx.restore();
    };

    const drawArm = (offsetX, offsetY, angle, front) => {
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.rotate(angle);
      const len = ROO.h * 0.28;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(len * 0.24, len * 0.26, len * 0.12, len * 0.6);
      ctx.quadraticCurveTo(-len * 0.04, len * 0.64, -len * 0.12, len * 0.36);
      ctx.closePath();
      ctx.fillStyle = front ? ROO_COLORS.mid : mix(ROO_COLORS.mid, ROO_COLORS.dark, 0.6);
      ctx.fill();
      ctx.restore();
    };

    const backLegAngle = 1.08 + swing * 0.32 + crouch * 0.12 - (grounded ? 0 : airStretch * 0.4);
    const frontLegAngle = 0.86 - swing * 0.42 - crouch * 0.08 + (grounded ? 0 : airStretch * 0.22);
    drawLeg(-ROO.w * 0.02, ROO.h * 0.14, backLegAngle, false);
    drawLeg(ROO.w * 0.18, ROO.h * 0.18 - crouch * 6, frontLegAngle, true);

    const armSwing = swing * (grounded ? 0.8 : 0.35);
    drawArm(ROO.w * 0.14, -ROO.h * 0.04, -1.05 - armSwing * 0.18 - crouch * 0.12, false);
    drawArm(ROO.w * 0.26, -ROO.h * 0.02 - crouch * 4, -0.7 + armSwing * 0.32 - crouch * 0.08, true);

    // Tail
    ctx.beginPath();
    ctx.moveTo(-ROO.w * 0.42, ROO.h * 0.02);
    ctx.quadraticCurveTo(-ROO.w * 0.72, -ROO.h * 0.12, -ROO.w * 0.52, -ROO.h * 0.42);
    ctx.quadraticCurveTo(-ROO.w * 0.18, -ROO.h * 0.26, -ROO.w * 0.12, -ROO.h * 0.04);
    ctx.quadraticCurveTo(-ROO.w * 0.36, ROO.h * 0.18, -ROO.w * 0.04, ROO.h * 0.28);
    ctx.closePath();
    ctx.fillStyle = ROO_COLORS.dark;
    ctx.fill();

    // Body
    ctx.beginPath();
    ctx.moveTo(-ROO.w * 0.12, -ROO.h * 0.26);
    ctx.quadraticCurveTo(ROO.w * 0.36, -ROO.h * 0.44, ROO.w * 0.44, ROO.h * 0.02);
    ctx.quadraticCurveTo(ROO.w * 0.46, ROO.h * 0.38, -ROO.w * 0.1, ROO.h * 0.32);
    ctx.quadraticCurveTo(-ROO.w * 0.3, ROO.h * 0.18, -ROO.w * 0.18, -ROO.h * 0.12);
    ctx.closePath();
    ctx.fillStyle = ROO_COLORS.base;
    ctx.fill();

    // Belly
    ctx.beginPath();
    ctx.moveTo(ROO.w * 0.08, -ROO.h * 0.12);
    ctx.quadraticCurveTo(ROO.w * 0.32, -ROO.h * 0.04, ROO.w * 0.28, ROO.h * 0.24);
    ctx.quadraticCurveTo(ROO.w * 0.02, ROO.h * 0.32, -ROO.w * 0.04, ROO.h * 0.12);
    ctx.closePath();
    ctx.fillStyle = ROO_COLORS.belly;
    ctx.fill();

    // Head & features
    const headBob = grounded ? swing * 4 : vy * 0.01;
    ctx.save();
    ctx.translate(ROO.w * 0.36, -ROO.h * 0.3 - headBob);
    ctx.rotate(clamp(tilt * 0.6, -0.32, 0.32));

    const earTilt = -0.4 + swing * 0.1;
    const drawEar = (offsetX, offsetY, flip) => {
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(flip ? -1 : 1, 1);
      ctx.rotate(earTilt + (flip ? 0.14 : -0.04));
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-ROO.w * 0.04, -ROO.h * 0.3, ROO.w * 0.06, -ROO.h * 0.34);
      ctx.quadraticCurveTo(ROO.w * 0.1, -ROO.h * 0.12, 0, 0);
      ctx.closePath();
      ctx.fillStyle = ROO_COLORS.base;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(ROO.w * 0.01, -ROO.h * 0.04);
      ctx.quadraticCurveTo(-ROO.w * 0.02, -ROO.h * 0.22, ROO.w * 0.04, -ROO.h * 0.26);
      ctx.quadraticCurveTo(ROO.w * 0.05, -ROO.h * 0.12, ROO.w * 0.01, -ROO.h * 0.04);
      ctx.closePath();
      ctx.fillStyle = mix(ROO_COLORS.belly, '#fde68a', 0.4);
      ctx.fill();
      ctx.restore();
    };

    drawEar(-ROO.w * 0.04, -ROO.h * 0.02, false);
    drawEar(-ROO.w * 0.12, -ROO.h * 0.04, true);

    ctx.beginPath();
    ctx.ellipse(0, 0, ROO.w * 0.22, ROO.h * 0.18, 0, 0, Math.PI * 2);
    ctx.fillStyle = ROO_COLORS.base;
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(ROO.w * 0.08, ROO.h * 0.02, ROO.w * 0.1, ROO.h * 0.08, 0, 0, Math.PI * 2);
    ctx.fillStyle = mix(ROO_COLORS.base, '#ffffff', 0.35);
    ctx.fill();

    ctx.fillStyle = ROO_COLORS.accent;
    ctx.beginPath();
    ctx.arc(ROO.w * 0.04, -ROO.h * 0.02, 3.4, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath();
    ctx.arc(ROO.w * 0.036, -ROO.h * 0.028, 1.4, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = ROO_COLORS.accent;
    ctx.beginPath();
    ctx.arc(ROO.w * 0.14, ROO.h * 0.04, 2.4, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
    ctx.restore();
  }

  // ===== Utils =====
  function rand(min, max) { return min + Math.random() * (max - min); }
  function clamp(v, a, b){ return v < a ? a : (v > b ? b : v); }
  function rectsOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function roundedRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2); ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y); ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr); ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
    ctx.lineTo(x, y + rr); ctx.quadraticCurveTo(x, y, x + rr, y);
    ctx.closePath();
  }

  function loadImage(url){
    return new Promise((res, rej) => {
      const im = new Image();
      im.crossOrigin = 'anonymous';
      im.onload = () => res(im);
      im.onerror = (e) => {
        console.error('Image failed to load:', url, e);
        rej(e);
      };
@@ -533,52 +639,53 @@
    g.drawImage(img, 0, 0);
    const d = g.getImageData(0,0,c.width,c.height), a = d.data;
    const [kr,kg,kb] = keyRGB;
    for (let i=0;i<a.length;i+=4){
      const r=a[i], gg=a[i+1], b=a[i+2];
      if (Math.abs(r-kr)<tol && Math.abs(gg-kg)<tol && Math.abs(b-kb)<tol) a[i+3]=0;
    }
    g.putImageData(d,0,0);
    return c;
  }

  function makeVariant(srcCanvas, brightness=1, saturation=1){
    const c = document.createElement('canvas'); c.width=srcCanvas.width; c.height=srcCanvas.height;
    const g = c.getContext('2d'); g.filter=`brightness(${brightness}) saturate(${saturation})`;
    g.drawImage(srcCanvas,0,0); return c;
  }

  function drawParallaxBand({ img, loaded, xOffset, y, h, layer }){
    const src = (loaded && img) ? img : (layer==='back' ? bandBack : bandFront);
    if (!src) return;

    const scale = h / src.height;
    const srcW = src.width;
    const tileW = srcW * scale;
    const fade = FADE_W * scale;
    const repeatDist = Math.max(1, tileW - fade);
    const offset = ((xOffset % repeatDist) + repeatDist) % repeatDist;
    let x = Math.round(-offset);

    for (let i=0; x < W + tileW; i++, x += repeatDist){
      if (layer==='back' && !BG_BACK_URL){ ctx.filter='blur(1.2px) saturate(0.88)'; ctx.globalAlpha=0.94; }
      if (BG_MIRROR_TILING && (i % 2)){
        ctx.save(); ctx.scale(-1,1);
        ctx.drawImage(src, -(x + tileW), y, tileW, h);
        ctx.restore();
      } else {
        ctx.drawImage(src, x, y, tileW, h);
      }
      if (layer==='back' && !BG_BACK_URL){ ctx.filter='none'; ctx.globalAlpha=1; }
    }
  }

  function createTreeBand(h, pal, density = 1.0, distant = false) {
    const tileW = 1280;
    const c = document.createElement('canvas'); c.width = tileW; c.height = h;
    const gc = c.getContext('2d');

    gc.fillStyle = mix(pal.leafDark, '#0b0d10', 0.25);
    gc.fillRect(0, h - 10, tileW, 10);

    let seed = (Math.random() * 1e9) | 0;
    const rng = () => { seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5; return (seed >>> 0) / 4294967296; };
