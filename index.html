<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <title>Hoparoo</title>
  <style>
    :root{--accent:#22c55e;--panel:rgba(255,255,255,.92);--ink:#0b0d10}
    html, body { height: 100%; margin: 0; background:#0b0d10; color:#fff; overflow:hidden; font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans"; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    /* HUD / Splash */
    .hud { position:fixed; inset:0; pointer-events:none; }
    .score { position:fixed; top: calc(env(safe-area-inset-top) + 18px); right: 14px; font-size: 56px; color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); z-index:3; user-select:none; }
    .best { position:fixed; top: calc(env(safe-area-inset-top) + 28px); left:14px; font-size:16px; color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); z-index:3; user-select:none; }
    .splash { position:fixed; inset:0; z-index:2; display:block; }
    .splash-inner { position:absolute; left:50%; transform:translateX(-50%); top:10%; width:min(92%,360px); text-align:center; }
    .title { font-size: 40px; font-weight: 1000; color:#fff; text-shadow:0 8px 24px rgba(0,0,0,.45); margin:0 0 6px; }
    .subtitle { font-size:16px; opacity:.95 }
    .panel { min-width:280px; max-width:90vw; background:var(--panel); color:#111; border-radius:18px; padding:16px; box-shadow:0 10px 40px rgba(0,0,0,.35); pointer-events:auto; }
    .btn { appearance:none; border:0; background:#fff; color:#111; padding:10px 14px; border-radius:999px; font-weight:800; box-shadow:0 2px 8px rgba(0,0,0,.15); cursor:pointer; line-height:1; }
    .btn:focus{ outline:3px solid #000; outline-offset:2px; }
    .actions { display:grid; gap:10px; margin-top:12px; justify-items:center; }
    .toast { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.85); color: #fff; padding: 8px 12px; border-radius: 10px; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity .25s ease, transform .25s ease; }
    .toast.show { opacity: 1; transform: translate(-50%, -6px); }
    .modal { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.35); z-index:9999; }
    .sr-only { position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    @media (prefers-color-scheme: light) {
      html,body{ background:#f3f5f7; color:#111; }
      .title{color:#111; text-shadow:none;}
    }
  </style>
</head>
<body>
  <canvas id="game" aria-label="Hoparoo"></canvas>

  <!-- HUD / Splash -->
  <div class="hud" aria-hidden="true">
    <div class="score"><span id="scoreHud">0</span></div>
    <div id="bestHud" class="best">Best: 0</div>
    <div id="splash" class="splash">
      <div class="splash-inner">
        <div class="title">Hoparoo</div>
        <div class="subtitle">Tap to jump • Dodge the outback</div>
        <div style="margin-top:12px; display:grid; gap:10px; justify-items:center; pointer-events:auto;">
          <button id="startBtn" class="btn" style="background:var(--accent); color:#04130a;">Play</button>
          <button id="howToBtn" class="btn">How to Play</button>
        </div>
      </div>
    </div>
  </div>

  <div id="gameOver" class="hud" style="display:none;">
    <div class="panel" role="dialog" aria-modal="true" aria-labelledby="overTitle" style="position:absolute; left:50%; top:45%; transform:translate(-50%,-50%);">
      <h2 id="overTitle" style="margin:0 0 8px; text-align:center;">Game Over</h2>
      <div style="display:flex; justify-content:space-between; font-size:18px; padding:6px 0;"><span>Your Score</span><strong id="scoreNow">0</strong></div>
      <div style="display:flex; justify-content:space-between; font-size:18px; padding:6px 0;"><span>Best</span><strong id="bestNow">0</strong></div>
      <div class="actions">
        <button id="againBtn" class="btn">Play Again</button>
        <button id="shareBtn" class="btn">Share</button>
      </div>
    </div>
  </div>

  <div id="howToModal" class="modal" role="dialog" aria-modal="true">
    <div class="panel" style="text-align:left;">
      <h3 style="margin:0 0 8px; text-align:center;">How to Play</h3>
      <p style="margin:0; line-height:1.45; font-size:15px;">
        • Roo runs automatically to the right<br>
        • Tap anywhere to jump<br>
        • Jump over obstacles on the ground<br>
        • Hitting anything ends the run — quick restart, go again
      </p>
      <div class="actions"><button id="closeHowToBtn" class="btn">Close</button></div>
    </div>
  </div>

  <div id="aria" class="sr-only" aria-live="polite"></div>
  <div id="toast" class="toast" role="status"></div>

<script>
(() => {
  'use strict';

  // ======= TWEAK ZONE =======
  const RUN_SPEED = 300;
  const GRAVITY = 2200;
  const JUMP_VELOCITY = -700; // Lower jumps for a chill vibe
  const GROUND_RATIO = 0.78;
  const FADE_W = 128; // Boosted fade for smoother tree blending—no more awkward seams!

  // Player size (logical hitbox), image will be scaled to this
  const ROO = { w: 96, h: 69 }; // Bigger kangaroo for that star power!

  // Optional fine-tune for sprite draw relative to the hitbox
  const ROO_IMG_OFFSET = { x: 0, y: 0 };
  const ROO_IMG_TILT = { up: 0.1, down: -0.08, max: 0.28 };

  // Remove black from trees.png
  const BG_CHROMA       = [0,0,0];
  const BG_CHROMA_TOL   = 34;                // raised for smoother edges
  const BG_MIRROR_TILING = true;             // Enabled for variety and better seam hiding

  const BOB = { amp: 24, freq: 5.5 }; // boosted for more hop-like animation
  const SPAWN_GAP = { min: 380, max: 720 };
  const OBSTACLE_TYPES = [
    { name: 'cactus', w: 42, h: 80, color: '#16a34a' },
    { name: 'rock',   w: 64, h: 48, color: '#4b5563' },
    { name: 'emu',    w: 58, h: 96 },
    { name: 'roo',    w: 52, h: 42 },
  ];

  const BOUNCE_DAMPING = 0.85; // Increased for bouncier feel (better bounce)

  // Parallax backgrounds (images optional; realistic fallback built-in)
  // ======= /TWEAK ZONE ======= 

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W, H, GROUND_Y;
  let roo = { x: 120, y: 0, vy: 0, grounded: true, bobT: 0 };
  let obstacles = [];
  let score = 0, best = 0;
  let worldX = 0;
  let running = false;

  // Parallax
  let bgBackX = 0, bgFrontX = 0;
  let backY, frontY, BACK_H, FRONT_H;
  let bgBackImg, bgBackLoaded = false;
  let bgFrontImg, bgFrontLoaded = false;
  let bandBack, bandFront;

  // Colors
  const SKY = ['#3b82f6', '#93c5fd'];
  const GROUND_COLOR = '#d97706';

  // Images (optional)
  const ROO_IMG_URL = ''; // e.g. 'https://example.com/roo.png'
  const BG_BACK_URL = ''; // e.g. 'https://example.com/trees_back.png'
  const BG_FRONT_URL = ''; // e.g. 'https://example.com/trees_front.png'
  let rooImg, rooImgLoaded = false;

  // Palettes for procedural trees
  const TREE_PAL_BACK = { trunkLight: '#6d28d9', trunkDark: '#4c1d95', leafLight: '#a855f7', leafMid: '#7e22ce', leafDark: '#581c87' };
  const TREE_PAL_FRONT = { trunkLight: '#3f6219', trunkDark: '#2a3f11', leafLight: '#84cc16', leafMid: '#65a30d', leafDark: '#4d7c0f' };

  init();

  async function init() {
    resize(); window.addEventListener('resize', resize);
    document.addEventListener('pointerdown', handleTap);
    if (ROO_IMG_URL) loadRooImg();
    if (BG_BACK_URL) loadBgBack();
    if (BG_FRONT_URL) loadBgFront();
    else createProceduralBands();
    setupHud();
    requestAnimationFrame(loop);
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.scale(dpr, dpr);
    W = window.innerWidth;
    H = window.innerHeight;
    GROUND_Y = H * GROUND_RATIO;
    roo.y = GROUND_Y - ROO.h;
    BACK_H = GROUND_Y * 0.45;
    FRONT_H = GROUND_Y * 0.65;
    backY = GROUND_Y - BACK_H;
    frontY = GROUND_Y - FRONT_H;
    if (!BG_BACK_URL) bandBack = createTreeBand(BACK_H, TREE_PAL_BACK, 0.65, true);
    if (!BG_FRONT_URL) bandFront = createTreeBand(FRONT_H, TREE_PAL_FRONT, 0.85);
  }

  async function loadRooImg() {
    try {
      rooImg = await loadImage(ROO_IMG_URL);
      rooImgLoaded = true;
    } catch {}
  }

  async function loadBgBack() {
    try {
      bgBackImg = await loadStripWithChroma(BG_BACK_URL, BG_CHROMA, BG_CHROMA_TOL);
      bgBackLoaded = true;
    } catch {}
  }

  async function loadBgFront() {
    try {
      bgFrontImg = await loadStripWithChroma(BG_FRONT_URL, BG_CHROMA, BG_CHROMA_TOL);
      bgFrontLoaded = true;
    } catch {}
  }

  function createProceduralBands() {
    bandBack = createTreeBand(BACK_H, TREE_PAL_BACK, 0.65, true);
    bandFront = createTreeBand(FRONT_H, TREE_PAL_FRONT, 0.85);
  }

  function handleTap(e) {
    if (!running) startGame();
    else if (roo.grounded) jump();
  }

  function jump() {
    roo.vy = JUMP_VELOCITY;
    roo.grounded = false;
  }

  function startGame() {
    running = true;
    score = 0;
    worldX = 0;
    obstacles = [];
    roo.y = GROUND_Y - ROO.h;
    roo.vy = 0;
    roo.grounded = true;
    document.getElementById('splash').style.display = 'none';
    document.getElementById('gameOver').style.display = 'none';
  }

  let lastT = 0;
  function loop(t) {
    requestAnimationFrame(loop);
    const dt = (t - lastT) / 1000;
    lastT = t;
    if (running) update(dt);
    draw();
  }

  let nextSpawn = 0;
  function update(dt) {
    worldX += RUN_SPEED * dt;
    bgBackX += RUN_SPEED * dt * 0.3;
    bgFrontX += RUN_SPEED * dt * 0.6;

    score = Math.floor(worldX / 100);
    document.getElementById('scoreHud').textContent = score;

    roo.bobT += dt * BOB.freq;
    if (roo.bobT > Math.PI * 2) roo.bobT -= Math.PI * 2;

    if (!roo.grounded) {
      roo.vy += GRAVITY * dt;
      roo.y += roo.vy * dt;
      if (roo.y >= GROUND_Y - ROO.h) {
        roo.y = GROUND_Y - ROO.h;
        roo.vy = 0;
        roo.grounded = true;
      }
    }

    spawnObstacles(dt);
    updateObstacles(dt);
    checkCollisions(dt);
  }

  function spawnObstacles(dt) {
    nextSpawn -= RUN_SPEED * dt;
    if (nextSpawn <= 0) {
      const type = OBSTACLE_TYPES[Math.floor(Math.random() * OBSTACLE_TYPES.length)];
      const o = { 
        x: W + 20, 
        y: GROUND_Y - type.h, 
        w: type.w, 
        h: type.h, 
        type: type.name, 
        color: type.color || (type.name === 'emu' ? '#92400e' : '#f59e0b') 
      };
      obstacles.push(o);
      nextSpawn = rand(SPAWN_GAP.min, SPAWN_GAP.max);
    }
  }

  function updateObstacles(dt) {
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      o.x -= RUN_SPEED * dt;
      if (o.x + o.w < 0) obstacles.splice(i, 1);
    }
  }

  function checkCollisions(dt) {
    const shrink = 0.75; // forgiving hitbox
    const rb = {
      x: roo.x + ROO.w * (1 - shrink) / 2,
      y: roo.y + ROO.h * (1 - shrink) / 2,
      w: ROO.w * shrink,
      h: ROO.h * shrink
    };
    let collided = false;
    for (const o of obstacles) {
      if (rectsOverlap(rb, o)) {
        collided = true;
        // Bounce instead of game over!
        roo.vy *= -BOUNCE_DAMPING; // Reverse velocity with some damping for bounce
        roo.y += roo.vy * dt; // Apply immediate bounce adjustment
        roo.grounded = false;
        break; // Only bounce off one at a time
      }
    }
    if (collided) {
      // Optional: Add a little sound or effect if you want later!
    }
  }

  function draw() {
    drawSky(); drawGround();
    for (const o of obstacles) drawObstacle(o);
    drawRoo();
  }

  function drawSky() {
    // Blue sky
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, SKY[0]); g.addColorStop(1, SKY[1]);
    ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

    // Clouds
    const t = performance.now() * 0.00006;
    ctx.globalAlpha = 0.14;
    for (let i = 0; i < 10; i++) {
      const cx = ((i * 311) - (t * 900)) % (W + 220) - 110;
      const cy = 40 + (i * 53) % (GROUND_Y * 0.6);
      const rw = 160 + (i % 3) * 60, rh = 40 + (i % 2) * 12;
      roundedRect(cx, cy, rw, rh, 20); ctx.fillStyle = '#ffffff'; ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Parallax bands
    drawParallaxBand({ img: bgBackImg, loaded: bgBackLoaded, xOffset: bgBackX, y: backY, h: BACK_H, layer: 'back' });
    drawParallaxBand({ img: bgFrontImg, loaded: bgFrontLoaded, xOffset: bgFrontX, y: frontY, h: FRONT_H, layer: 'front' });
  }

  function drawGround() {
    ctx.fillStyle = GROUND_COLOR; ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
    const dashW = 32, dashH = 3, gap = 20;
    const offset = -((performance.now() * RUN_SPEED * 0.002) % (dashW + gap));
    ctx.globalAlpha = 0.35; ctx.fillStyle = '#9ca3af';
    for (let x = offset; x < W + dashW; x += dashW + gap) ctx.fillRect(x, GROUND_Y + 18, dashW, dashH);
    ctx.globalAlpha = 1;
  }

  function drawObstacle(o) {
    ctx.fillStyle = o.color;
    if (o.type === 'emu') {
      ctx.fillRect(o.x, o.y, o.w, o.h - 12);
      ctx.fillRect(o.x + o.w - 12, o.y - 8, 12, 12);
    } else if (o.type === 'roo') {
      roundedRect(o.x, o.y + 6, o.w, o.h - 6, 8); ctx.fill();
      ctx.fillRect(o.x + o.w - 10, o.y - 6, 10, 12);
    } else {
      roundedRect(o.x, o.y + 8, o.w, o.h - 8, 6); ctx.fill();
    }
  }

  function drawRoo(){
    const sinVal = Math.sin(roo.bobT);
    const bobOffset = (roo.grounded ? -sinVal * BOB.amp : 0);
    const x = roo.x, y = roo.y + bobOffset;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.28; ctx.filter='blur(1px)';
    ctx.beginPath(); ctx.ellipse(x + ROO.w*0.5, GROUND_Y - 2, ROO.w*0.42, 3, 0, 0, Math.PI*2);
    ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fill(); ctx.restore();

    if (rooImgLoaded && rooImg){
      const tilt = !roo.grounded ? (roo.vy < 0 ? ROO_IMG_TILT.up : ROO_IMG_TILT.down) : (-sinVal * 0.12);
      let scaleX = 1;
      let scaleY = 1;
      if (roo.grounded) {
        scaleY = 1 + sinVal * 0.15; // boosted squash/stretch for hop feel
        scaleX = 1 - sinVal * 0.08;
      } else {
        const stretchFactor = Math.abs(roo.vy) / 500; // normalize based on velocity
        scaleY = 1 - stretchFactor * 0.15;
        scaleX = 1 + stretchFactor * 0.05;
        if (roo.vy < 0) { // rising
          scaleY = 1 + stretchFactor * 0.15;
          scaleX = 1 - stretchFactor * 0.05;
        }
      }
      ctx.save();
      const cx = x + ROO.w/2, cy = y + ROO.h/2;
      ctx.translate(cx, cy);
      ctx.scale(scaleX, scaleY);
      ctx.rotate(clamp(tilt, -ROO_IMG_TILT.max, ROO_IMG_TILT.max));
      ctx.drawImage(rooImg, -ROO.w/2 + ROO_IMG_OFFSET.x, -ROO.h/2 + ROO_IMG_OFFSET.y, ROO.w, ROO.h);
      ctx.restore();
    } else {
      // fallback blocky roo
      ctx.fillStyle = '#22c55e';
      roundedRect(x, y + 6, ROO.w, ROO.h - 6, 10); ctx.fill();
      ctx.fillRect(x + ROO.w - 18, y - 10, 18, 18);
      ctx.fillRect(x + ROO.w - 10, y - 20, 8, 12);
      ctx.fillRect(x - 14, y + 12, 14, 6);
    }
  }

  // ===== Utils =====
  function rand(min, max) { return min + Math.random() * (max - min); }
  function clamp(v, a, b){ return v < a ? a : (v > b ? b : v); }
  function rectsOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function roundedRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2); ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y); ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr); ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
    ctx.lineTo(x, y + rr); ctx.quadraticCurveTo(x, y, x + rr, y);
  }

  function loadImage(url){
    return new Promise((res, rej)=>{
      const im = new Image(); im.crossOrigin='anonymous';
      im.onload=()=>res(im); im.onerror=rej; im.src=url;
    });
  }

  // Chroma-key near-black pixels to transparent
  async function loadStripWithChroma(url, keyRGB, tol){
    const img = await loadImage(url);
    const c = document.createElement('canvas'); c.width = img.width; c.height = img.height;
    const g = c.getContext('2d', { willReadFrequently:true });
    g.drawImage(img, 0, 0);
    const d = g.getImageData(0,0,c.width,c.height), a = d.data;
    const [kr,kg,kb] = keyRGB;
    for (let i=0;i<a.length;i+=4){
      const r=a[i], gg=a[i+1], b=a[i+2];
      if (Math.abs(r-kr)<tol && Math.abs(gg-kg)<tol && Math.abs(b-kb)<tol) a[i+3]=0;
    }
    g.putImageData(d,0,0);
    return c; // canvas usable by drawImage
  }

  function makeVariant(srcCanvas, brightness=1, saturation=1){
    const c = document.createElement('canvas'); c.width=srcCanvas.width; c.height=srcCanvas.height;
    const g = c.getContext('2d'); g.filter=`brightness(${brightness}) saturate(${saturation})`;
    g.drawImage(srcCanvas,0,0); return c;
  }

  // Parallax bands (image or procedural)
  function drawParallaxBand({ img, loaded, xOffset, y, h, layer }){
    // prefer image/canvas; else use existing procedural band if present
    const src = (loaded && img && (img.width || img.naturalWidth))
      ? img
      : (layer==='back' ? bandBack.canvas : bandFront.canvas);
    if (!src) return;

    const scale = h / src.height;
    const srcW = src.width;
    const tileW = srcW * scale;
    const fade = FADE_W * scale;
    const repeatDist = tileW - fade;
    const blurBack = (layer==='back' && !BG_BACK_URL); // only blur if reusing front
    let x = -((xOffset % repeatDist) + repeatDist) % repeatDist;

    for (let i=0; x < W + tileW; i++, x += repeatDist){
      if (blurBack){ ctx.filter='blur(1px) saturate(0.9)'; ctx.globalAlpha=0.95; }
      if (BG_MIRROR_TILING && (i % 2)){
        // Use negative width for mirroring without scale
        ctx.drawImage(src, x + tileW, y, -tileW, h);
      } else {
        ctx.drawImage(src, x, y, tileW, h);
      }
      if (blurBack){ ctx.filter='none'; ctx.globalAlpha=1; }
    }
  }

  function createTreeBand(h, pal, density = 1.0, distant = false) {
    const tileW = 1280;
    const c = document.createElement('canvas'); c.width = tileW; c.height = h;
    const gc = c.getContext('2d');

    gc.fillStyle = mix(pal.leafDark, '#0b0d10', 0.2);
    gc.fillRect(0, h - 12, tileW, 12);

    let seed = (Math.random() * 1e9) | 0;
    const rng = () => { seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5; return (seed >>> 0) / 4294967296; };

    const count = Math.floor((tileW / 36) * density);
    for (let i = 0; i < count; i++) {
      const baseX = (i * (tileW / count)) + rng() * 18;
      const spread = 18 + rng() * 28;
      const trunkW = 6 + rng() * 5;
      const height = (h * (distant ? 0.35 : 0.45)) + rng() * (h * (distant ? 0.15 : 0.2)); // Reduced height to better match kangaroo scale
      const baseY = h;

      const gx = baseX + spread * 0.45;
      const gyTop = baseY - height;
      const trunkGrad = gc.createLinearGradient(0, gyTop, 0, baseY);
      trunkGrad.addColorStop(0, pal.trunkLight);
      trunkGrad.addColorStop(1, pal.trunkDark);
      gc.fillStyle = trunkGrad;
      gc.fillRect(gx, gyTop, trunkW, height);

      // Add branches for more realism
      gc.fillStyle = pal.trunkDark;
      const branchCount = distant ? 1 : 2 + Math.floor(rng() * 2);
      for (let b = 0; b < branchCount; b++) {
        const side = rng() > 0.5 ? 1 : -1;
        const bx = gx + (trunkW / 2) * side;
        const by = gyTop + height * (0.4 + rng() * 0.4);
        const branchLength = (15 + rng() * 25) * (distant ? 0.7 : 1);
        const branchWidth = (2 + rng() * 3) * (distant ? 0.8 : 1);
        const angle = (0.3 + rng() * 0.4) * Math.PI / 2 * side;
        gc.save();
        gc.translate(bx, by);
        gc.rotate(angle);
        gc.fillRect(0, -branchWidth / 2, branchLength, branchWidth);
        gc.restore();
      }

      const cx = baseX;
      const cy = gyTop + height * (distant ? 0.35 : 0.28);

      paintLeaves(gc, cx, cy, spread, height * (distant ? 0.48 : 0.62), pal, distant);

      gc.save();
      gc.globalAlpha = 0.25;
      gc.filter = 'blur(0.6px)';
      roundedRect(baseX - spread * 0.2, h - 4, spread * 1.2, 4, 2); gc.fill();
      gc.restore();
    }

    // No old fades; add new edge fades instead
    addEdgeFades(c, FADE_W);

    return { canvas: c, w: tileW, h };
  }

  function paintLeaves(gc, cx, cy, w, h, pal, distant) {
    gc.fillStyle = pal.leafDark; 
    organicBlob(gc, cx, cy, w, h); gc.fill(); // Main canopy
    // Add side lobes for bushier, more realistic trees
    organicBlob(gc, cx - w*0.3, cy + h*0.1, w*0.5, h*0.6); gc.fill();
    organicBlob(gc, cx + w*0.3, cy + h*0.1, w*0.5, h*0.6); gc.fill();

    gc.fillStyle = pal.leafMid;  
    organicBlob(gc, cx, cy - h*0.08, w*0.9, h*0.78); gc.fill();
    organicBlob(gc, cx - w*0.3, cy + h*0.1 - h*0.08, w*0.45, h*0.7); gc.fill();
    organicBlob(gc, cx + w*0.3, cy + h*0.1 - h*0.08, w*0.45, h*0.7); gc.fill();

    const hl = gc.createRadialGradient(cx, cy - h*0.25, 10, cx, cy - h*0.25, Math.max(20, w*0.9));
    hl.addColorStop(0, pal.leafLight); hl.addColorStop(1, 'rgba(255,255,255,0)');
    gc.fillStyle = hl; 
    organicBlob(gc, cx + 4, cy - h*0.18, w*0.8, h*0.5); gc.fill();
    organicBlob(gc, cx - w*0.3 + 4, cy + h*0.1 - h*0.18, w*0.4, h*0.45); gc.fill();
    organicBlob(gc, cx + w*0.3 + 4, cy + h*0.1 - h*0.18, w*0.4, h*0.45); gc.fill();

    gc.save();
    gc.globalAlpha = distant ? 0.08 : 0.12;
    for (let i = 0; i < 22; i++) {
      const px = cx + (Math.random() - 0.5) * w * 0.9;
      const py = cy - h*0.2 + (Math.random() - 0.2) * h * 0.7;
      roundedRect(px, py, 6 + Math.random()*8, 4 + Math.random()*6, 2); gc.fillStyle = pal.leafLight; gc.fill();
    }
    gc.restore();
  }

  function organicBlob(gc, cx, cy, w, h) {
    gc.beginPath();
    gc.moveTo(cx - w/2, cy);
    gc.bezierCurveTo(cx - w*0.55, cy - h*0.35, cx - w*0.25, cy - h*0.75, cx, cy - h*0.7);
    gc.bezierCurveTo(cx + w*0.25, cy - h*0.75, cx + w*0.55, cy - h*0.35, cx + w/2, cy);
    gc.bezierCurveTo(cx + w*0.55, cy + h*0.35, cx + w*0.25, cy + h*0.5, cx, cy + h*0.45);
    gc.bezierCurveTo(cx - w*0.25, cy + h*0.5, cx - w*0.55, cy + h*0.35, cx - w/2, cy);
  }

  function mix(hex, hex2, t) {
    const a = parseInt(hex.slice(1),16), b = parseInt(hex2.slice(1),16);
    const r = (a>>16)&255, g=(a>>8)&255, bl=a&255;
    const r2=(b>>16)&255, g2=(b>>8)&255, bl2=b&255;
    const rr = Math.round(r + (r2-r)*t), gg=Math.round(g+(g2-g)*t), bb=Math.round(bl+(bl2-bl)*t);
    return `#${((1<<24)+(rr<<16)+(gg<<8)+bb).toString(16).slice(1)}`;
  }

  function addEdgeFades(c, fadeW) {
    const gc = c.getContext('2d');
    const gradL = gc.createLinearGradient(0, 0, fadeW, 0);
    gradL.addColorStop(0, 'rgba(0,0,0,0)'); gradL.addColorStop(1, 'rgba(0,0,0,1)');
    gc.fillStyle = gradL; gc.globalCompositeOperation = 'destination-out';
    gc.fillRect(0, 0, fadeW, c.height);
    const gradR = gc.createLinearGradient(c.width - fadeW, 0, c.width, 0);
    gradR.addColorStop(0, 'rgba(0,0,0,1)'); gradR.addColorStop(1, 'rgba(0,0,0,0)');
    gc.fillStyle = gradR;
    gc.fillRect(c.width - fadeW, 0, fadeW, c.height);
    gc.globalCompositeOperation = 'source-over';
  }

  function setupHud() {
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('howToBtn').addEventListener('click', () => document.getElementById('howToModal').style.display = 'grid');
    document.getElementById('closeHowToBtn').addEventListener('click', () => document.getElementById('howToModal').style.display = 'none');
    // Add game over logic if needed, but since we have bounce, maybe remove game over or trigger on multiple collisions
    // For now, assuming bounce replaces game over
  }

})();
</script>
</body>
</html>
