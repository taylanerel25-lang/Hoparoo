<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <title>Hoparoo</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b0d10; color:#fff; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    /* Optional: system font for overlays */
    @media (prefers-color-scheme: light) { html,body{ background:#f3f5f7; color:#111; } }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(() => {
  'use strict';// ======= TWEAK ZONE ======= const RUN_SPEED = 300;                // world scroll speed (px/s) const GRAVITY = 2200;                 // px/s^2 const JUMP_VELOCITY = -900;           // px/s (negative = up) const GROUND_RATIO = 0.78;            // ground baseline (fraction of screen height) const ROO = { w: 64, h: 46 };         // kangaroo hitbox (change later for sprite) const BOB = { amp: 6, freq: 6.5 };    // tiny hop/bob when grounded (visual only) const SPAWN_GAP = { min: 380, max: 720 }; // distance between obstacles (px) const SAFE_START_MS = 1200;           // no obstacles at the very start const SKY = ['#0b0d10', '#111827'];   // background gradient (dark) const GROUND_COLOR = '#374151'; const KANGAROO_COLOR = '#22c55e';     // placeholder color const OBSTACLE_COLORS = ['#f59e0b', '#ef4444', '#60a5fa']; // placeholder colors

// Placeholder obstacle shapes you can swap later for sprites const OBSTACLE_TYPES = [ { name: 'rock',   w: 38, h: 34 }, { name: 'emu',    w: 28, h: 62 }, { name: 'roo',    w: 52, h: 42 }, ]; // ======= /TWEAK ZONE =======

const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d'); let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // keep sane

let W = 0, H = 0, GROUND_Y = 0; function resize() { W = Math.floor(window.innerWidth); H = Math.floor(window.innerHeight); canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR); ctx.setTransform(DPR, 0, 0, DPR, 0, 0); GROUND_Y = Math.floor(H * GROUND_RATIO); } window.addEventListener('resize', resize, { passive: true }); resize();

// Game state const state = { playing: false, dead: false, time: 0, score: 0, best: 0, distSinceSpawn: 0, nextGap: rand(SPAWN_GAP.min, SPAWN_GAP.max), startedAt: 0, };

// Roo (player) const roo = { x: Math.max(80, W * 0.18), y: 0,              // top-left y for hitbox vy: 0, grounded: true, bobT: 0, }; function placeRooOnGround() { roo.y = GROUND_Y - ROO.h; roo.vy = 0; roo.grounded = true; } placeRooOnGround();

// Obstacles /** @type {{x:number,y:number,w:number,h:number,type:string,color:string}[]} */ const obstacles = [];

function spawnObstacle() { const t = OBSTACLE_TYPES[(Math.random() * OBSTACLE_TYPES.length) | 0]; const color = OBSTACLE_COLORS[(Math.random() * OBSTACLE_COLORS.length) | 0]; const h = t.h; const w = t.w; const y = GROUND_Y - h; const x = W + rand(12, 48); // just off-screen to the right obstacles.push({ x, y, w, h, type: t.name, color }); }

// Input function jump() { if (state.dead) return; if (!state.playing) { startGame(); return; } if (roo.grounded) { roo.vy = JUMP_VELOCITY; roo.grounded = false; } } window.addEventListener('pointerdown', jump); window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { e.preventDefault(); jump(); } if (state.dead && (e.code === 'Space' || e.code === 'Enter')) restart(); });

document.addEventListener('visibilitychange', () => { // If tab gets hidden, avoid physics time-skips lastTime = performance.now(); });

function startGame() { state.playing = true; state.dead = false; state.time = 0; state.score = 0; state.distSinceSpawn = 0; state.nextGap = rand(SPAWN_GAP.min, SPAWN_GAP.max); state.startedAt = performance.now(); obstacles.length = 0; placeRooOnGround(); }

function gameOver() { state.dead = true; state.playing = false; state.best = Math.max(state.best, Math.floor(state.score)); }

function restart() { startGame(); }

// Main loop let lastTime = performance.now(); function loop(now) { const rawDt = (now - lastTime) / 1000; lastTime = now; const dt = Math.min(0.033, Math.max(0.001, rawDt));

update(dt);
draw();

requestAnimationFrame(loop);

} requestAnimationFrame(loop);

function update(dt) { // Score increases with distance covered if (state.playing) state.score += (RUN_SPEED * dt) * 0.1; // simple scaling

// Spawn logic (delay a moment at start)
if (state.playing && (performance.now() - state.startedAt) > SAFE_START_MS) {
  state.distSinceSpawn += RUN_SPEED * dt;
  if (state.distSinceSpawn >= state.nextGap) {
    spawnObstacle();
    state.distSinceSpawn = 0;
    // Slight difficulty ramp: shrink max gap a bit over time
    const ramp = Math.max(0.6, 1 - state.score / 2000);
    state.nextGap = rand(SPAWN_GAP.min * ramp, SPAWN_GAP.max * ramp);
  }
}

// Move obstacles left
for (let i = obstacles.length - 1; i >= 0; i--) {
  const o = obstacles[i];
  if (state.playing) o.x -= RUN_SPEED * dt;
  if (o.x + o.w < -20) obstacles.splice(i, 1);
}

// Roo physics
if (state.playing) {
  if (!roo.grounded) {
    roo.vy += GRAVITY * dt;
    roo.y += roo.vy * dt;
    if (roo.y >= GROUND_Y - ROO.h) {
      placeRooOnGround();
    }
  } else {
    // grounded tiny visual bob
    roo.bobT += dt * BOB.freq;
  }
}

// Collision (AABB)
if (state.playing) {
  const rb = { x: roo.x, y: roo.y, w: ROO.w, h: ROO.h };
  for (const o of obstacles) {
    if (rectsOverlap(rb, o)) {
      gameOver();
      break;
    }
  }
}

}

function draw() { // Background drawSky(); drawGround();

// Obstacles
for (const o of obstacles) drawObstacle(o);

// Player
drawRoo();

// HUD
drawHUD();

if (!state.playing && !state.dead) drawPrompt();
if (state.dead) drawGameOver();

}

function drawSky() { const g = ctx.createLinearGradient(0, 0, 0, H); g.addColorStop(0, SKY[0]); g.addColorStop(1, SKY[1]); ctx.fillStyle = g; ctx.fillRect(0, 0, W, H); // Simple parallax dots (stars/dust) const t = performance.now() * 0.0001; ctx.globalAlpha = 0.25; for (let i = 0; i < 40; i++) { const x = ((i * 97) % W) - ((t * 50) % W); const y = (i * 67) % (GROUND_Y - 40); ctx.fillStyle = 'white'; ctx.fillRect((x + W) % W, y, 2, 2); } ctx.globalAlpha = 1; }

function drawGround() { ctx.fillStyle = GROUND_COLOR; ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y); // little dashes to imply motion const dashW = 32, dashH = 3, gap = 20; const offset = -((performance.now() * RUN_SPEED * 0.002) % (dashW + gap)); ctx.globalAlpha = 0.35; ctx.fillStyle = '#9ca3af'; for (let x = offset; x < W + dashW; x += dashW + gap) { ctx.fillRect(x, GROUND_Y + 18, dashW, dashH); } ctx.globalAlpha = 1; }

function drawObstacle(o) { ctx.fillStyle = o.color; // Use shape hint by type (purely cosmetic for now) if (o.type === 'emu') { // tall rectangle with a small head ctx.fillRect(o.x, o.y, o.w, o.h - 12); ctx.fillRect(o.x + o.w - 12, o.y - 8, 12, 12); } else if (o.type === 'roo') { // wider, kangaroo-ish blob roundedRect(o.x, o.y + 6, o.w, o.h - 6, 8); ctx.fill(); ctx.fillRect(o.x + o.w - 10, o.y - 6, 10, 12); // ear } else { // rock roundedRect(o.x, o.y + 8, o.w, o.h - 8, 6); ctx.fill(); } }

function drawRoo() { const bobOffset = (roo.grounded ? Math.sin(roo.bobT) * BOB.amp : 0); const x = roo.x, y = roo.y + bobOffset;

// Simple body
ctx.fillStyle = KANGAROO_COLOR;
roundedRect(x, y + 6, ROO.w, ROO.h - 6, 10); ctx.fill();
// head
ctx.fillRect(x + ROO.w - 18, y - 10, 18, 18);
// ear
ctx.fillRect(x + ROO.w - 10, y - 20, 8, 12);
// tail
ctx.fillRect(x - 14, y + 12, 14, 6);

// feet flash when landing
if (roo.grounded) {
  ctx.globalAlpha = 0.4;
  ctx.fillRect(x + 6, GROUND_Y - 2, 22, 2);
  ctx.fillRect(x + ROO.w - 28, GROUND_Y - 2, 22, 2);
  ctx.globalAlpha = 1;
}

}

function drawHUD() { ctx.font = '600 18px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell'; ctx.textBaseline = 'top'; ctx.fillStyle = 'rgba(255,255,255,0.9)'; const s = Math.floor(state.score); ctx.fillText(m: ${s}, 14, 14); if (state.best > 0) { ctx.fillText(best: ${state.best}, 14, 36); } }

function drawPrompt() { ctx.font = '700 24px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fillText('Tap to hop → jump over obstacles', W/2, H/2 - 8); ctx.font = '400 14px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell'; ctx.fillText('Space/↑ also works • single jump • no sprites yet', W/2, H/2 + 20); }

function drawGameOver() { ctx.font = '800 32px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = 'rgba(255,255,255,0.98)'; ctx.fillText('BONK!', W/2, H/2 - 22); ctx.font = '600 18px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell'; ctx.fillText('Tap to try again', W/2, H/2 + 6); }

// ===== Utils ===== function rand(min, max) { return min + Math.random() * (max - min); } function rectsOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; } function roundedRect(x, y, w, h, r) { const rr = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x + rr, y); ctx.lineTo(x + w - rr, y); ctx.quadraticCurveTo(x + w, y, x + w, y + rr); ctx.lineTo(x + w, y + h - rr); ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h); ctx.lineTo(x + rr, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - rr); ctx.lineTo(x, y + rr); ctx.quadraticCurveTo(x, y, x + rr, y); } })(); </script>

</body>
</html>
